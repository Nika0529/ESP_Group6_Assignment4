LMMprof <- function(theta, X, Z, y){
  #QR分解
  QR_Z <- qr(Z)
  R <- qr.R(QR_Z)
  sigma2 <- exp(theta[1])^2
  psi <- diag(exp(theta[-1]^2))
  #设置矩阵
  n <- nrow(Z)
  p <- ncol(Z)
  Rpsi <- R %*% psi %*% t(R) + diag(sigma2, p)
  #它的逆矩阵
  L <- chol(Rpsi)
  Rpsi_inv <- backsolve(t(L), forwardsolve(L, diag(ncol(L))))
  #算Wy和WX
  Qty <- qr.qty(QR_Z, y)
  QtX <- qr.qty(QR_Z, X)
  Rspi_Qty <- c(Rpsi_inv%*%Qty[1:p,], diag(1/sigma2, n-p)%*%Qty[p+1:n,])
  W_y <- qr.qy(QR_Z, Rspi_Qty)
  Rspi_QtX <- c(Rpsi_inv%*%QtX[1:p,], diag(1/sigma2, n-p)%*%QtX[p+1:n,])
  W_X <- qr.qy(QR_Z, Rpsi_QtX)
  #算XWX和XWy
  XtWX <- t(X) %*% W_X
  XtWy <- t(X) %*% W_y
  #算beta
  L1 <- chol(XtWX)
  beta_hat <- backsolve(t(L1), forwardsolve(L1, XtWy))
  
  #计算负对数似然值
  res <- y - (X %*% beta_hat)
  log_likelihood <- 0.5 * (t(resid) %*% W_y + sum(log(diag(qr.R(QR_A)))) + (nrow(X) - ncol(R)) * log(sigma2))
  
  #返回负对数似然值，并将 beta_hat 存为属性
  attr(log_likelihood, "beta_hat") <- beta_hat
  return(as.numeric(log_likelihood))
}









LMMprof <- function(theta, X, Z, y) {
  # Step 1: 提取方差参数
  sigma2 <- exp(theta[1])^2  # 残差的方差 sigma^2
  psi_theta <- diag(exp(theta[-1])^2)  # 随机效应方差矩阵 Psi_theta
  
  # Step 2: 对 Z 进行 QR 分解，获取 QR 对象
  QR_Z <- qr(Z)
  R <- qr.R(QR_Z)  # 获取 R 矩阵
  
  # Step 3: 构建 A = R Psi_theta R^T + I_p sigma^2
  A <- R %*% psi_theta %*% t(R) + diag(sigma2, ncol(R))

  # Step 4: 使用 Cholesky 分解来替代求逆，构建 W y 和 W X
  # 将 y 和 X 投影到 Q 的空间
  y_proj <- qr.qty(QR_Z, y)  # 使用 qr.qty 计算 Q^T y
  X_proj <- qr.qty(QR_Z, X)  # 使用 qr.qty 计算 Q^T X
  
  # 对分块矩阵进行运算，使用 Cholesky 分解来求解线性系统
  L_A <- chol(A)  # 对 A 进行 Cholesky 分解，A = L_A %*% t(L_A)
  
  # 计算 W y 的分块部分
  # 求解 L_A %*% z = y_proj[1:ncol(R)] 以及 t(L_A) %*% W_y1 = z
  z <- forwardsolve(L_A, y_proj[1:ncol(R)])
  W_y1 <- backsolve(t(L_A), z)
  W_y2 <- y_proj[(ncol(R) + 1):length(y_proj)] / sigma2  # 后 n-p 维度的缩放
  W_y_proj <- c(W_y1, W_y2)  # 合并分块结果

  # 计算 W X 的分块部分
  W_X1 <- apply(X_proj[1:ncol(R), ], 2, function(col) {
    z <- forwardsolve(L_A, col)
    backsolve(t(L_A), z)
  })
  W_X2 <- X_proj[(ncol(R) + 1):nrow(X_proj), ] / sigma2  # 后 n-p 维度的缩放
  W_X_proj <- rbind(W_X1, W_X2)  # 合并分块结果

  # 使用 qr.qy 将投影结果转换回原始空间
  W_y <- qr.qy(QR_Z, W_y_proj)
  W_X <- qr.qy(QR_Z, W_X_proj)
  
  # Step 5: 计算 XtWX 和 XtWy
  XtWX <- t(X) %*% W_X
  XtWy <- t(X) %*% W_y
  
  # Step 6: 使用 Cholesky 分解计算 beta_hat
  L_XtWX <- chol(XtWX)
  z <- forwardsolve(t(L_XtWX), XtWy)
  beta_hat <- backsolve(L_XtWX, z)

  # Step 7: 计算负对数似然值
  resid <- y - X %*% beta_hat
  log_likelihood <- 0.5 * (t(resid) %*% W_y + sum(log(diag(L_A))) + (nrow(X) - ncol(R)) * log(sigma2))
  
  # Step 8: 返回负对数似然值，并将 beta_hat 存为属性
  attr(log_likelihood, "beta_hat") <- beta_hat
  return(as.numeric(log_likelihood))
}